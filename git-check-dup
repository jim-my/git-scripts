#!/usr/bin/env bash
set -euo pipefail

# =============================================================================
# git-check-dup - Find Duplicate Commits Between Branches
# =============================================================================
#
# PURPOSE:
#   Detects commits with identical CONTENT (same patch-id) between your current
#   branch and a remote branch. These are commits that make the exact same changes
#   to the code but may have different commit hashes, timestamps, or authors.
#
# WHAT ARE "DUPLICATE" COMMITS?
#   - Same code changes (additions, deletions, modifications)
#   - Different commit hashes (due to different commit times/authors)
#   - Often created by: cherry-picking, rebasing, manual re-application
#   - NOT the same as commits with identical messages but different content
#
# HOW IT WORKS:
#   1. Finds common ancestor between branches
#   2. Collects all commits since that point from both branches  
#   3. Computes patch-id for each commit (content fingerprint)
#   4. Reports commits with matching patch-ids as duplicates
#
# USAGE:
#   git-check-dup [--quiet|-q] [remote_branch]
#
# EXAMPLES:
#   git-check-dup                           # Check against origin/main
#   git-check-dup upstream/develop          # Check against specific branch
#   git-check-dup --quiet origin/main       # Pipe-friendly output
#   git-check-dup -q | wc -l               # Count duplicates
#   git-check-dup -q | cut -d' ' -f1       # Get local commit hashes
#
# OUTPUT FORMATS:
#   Default: Header + detailed commit info with dates and messages
#   Quiet:   Just "local_hash remote_hash patch_id" for shell pipes
#
# USE CASES:
#   - Before rebasing: Check if your commits already exist upstream
#   - After cherry-picking: Verify which commits were successfully applied
#   - Code review: Identify redundant commits in pull requests
#   - Branch cleanup: Find commits that can be safely dropped
# =============================================================================

quiet=false
remote_branch="origin/main"

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        -q|--quiet)
            quiet=true
            ;;
        -*)
            echo "Usage: git-check-dup [-q|--quiet] [remote_branch]" >&2
            exit 1
            ;;
        *)
            remote_branch="$1"
            ;;
    esac
    shift
done

# Check if remote branch exists
if ! git rev-parse --verify --quiet "$remote_branch" >/dev/null 2>&1; then
    echo "Error: Remote branch ${remote_branch} not found." >&2
    exit 1
fi

# Find common ancestor
merge_base=$(git merge-base HEAD "$remote_branch" 2>/dev/null || echo "$remote_branch")

# Create temp files
local_patches=$(mktemp)
remote_patches=$(mktemp)

# Get patch IDs for local commits (using for loop to avoid stdin issues)
for hash in $(git log --pretty=format:'%H' "${merge_base}"..HEAD); do
    patch_id=$(git show "$hash" | git patch-id --stable | cut -d' ' -f1)
    echo "$patch_id $hash" >> "$local_patches"
done

# Get patch IDs for remote commits
for hash in $(git log --pretty=format:'%H' "${merge_base}".."$remote_branch"); do
    patch_id=$(git show "$hash" | git patch-id --stable | cut -d' ' -f1)
    echo "$patch_id $hash" >> "$remote_patches"
done

# Find duplicates by joining on patch_id
join -j 1 <(sort "$local_patches") <(sort "$remote_patches") | while read -r patch_id local_hash remote_hash; do
    if [[ "$quiet" == "true" ]]; then
        # Quiet mode: just the essential data for pipes
        echo "$local_hash $remote_hash $patch_id"
    else
        # Default mode: header + detailed info
        current_branch=$(git rev-parse --abbrev-ref HEAD)
        
        # Header line aligned with data
        printf "%-40s %-40s %s\n" "Local" "Remote($remote_branch)" "Patch_id"
        printf "%-40s %-40s %s\n" "$local_hash" "$remote_hash" "$patch_id"
        
        # Get commit details
        local_date=$(git log -1 --pretty=format:'%ad' --date=short "$local_hash")
        local_msg=$(git log -1 --pretty=format:'%s' "$local_hash")
        remote_date=$(git log -1 --pretty=format:'%ad' --date=short "$remote_hash")
        remote_msg=$(git log -1 --pretty=format:'%s' "$remote_hash")
        
        echo "    ${local_hash:0:8}: $local_date $local_msg"
        echo "    ${remote_hash:0:8}: $remote_date $remote_msg"
    fi
done

# Cleanup
rm -f "$local_patches" "$remote_patches"
