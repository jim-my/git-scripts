#!/usr/bin/env python3
"""
git-stash-smart: Enhanced Git stash management with better UX

Provides an improved interface for Git stash operations with descriptive names,
easy searching, and better visualization of stashed changes.

Usage:
    git-stash-smart save <description>     # Save with descriptive name
    git-stash-smart list                   # List all stashes with previews
    git-stash-smart show <id|keyword>      # Show stash contents
    git-stash-smart apply <id|keyword>     # Apply stash (keep in stash list)
    git-stash-smart pop <id|keyword>       # Pop stash (remove from list)
    git-stash-smart drop <id|keyword>      # Delete stash
    git-stash-smart search <keyword>       # Search stashes by description
    git-stash-smart diff <id|keyword>      # Show diff for stash
    git-stash-smart branch <name> <id|keyword>  # Create branch from stash
    git-stash-smart clean                  # Interactive cleanup of old stashes

Features:
- Descriptive names instead of cryptic stash@{0}
- Keyword-based search and selection
- Rich preview of stash contents
- Interactive stash management
- Time-based organization
- Safety confirmations for destructive operations
"""

import sys
import subprocess
import re
import json
from datetime import datetime, timedelta
from pathlib import Path
import argparse
from typing import List, Dict, Optional, Tuple


class GitStashSmartError(Exception):
    """Custom exception for git-stash-smart operations"""
    pass


class StashInfo:
    """Represents a Git stash with enhanced metadata"""
    def __init__(self, stash_ref: str, description: str, branch: str, timestamp: str, files_count: int = 0):
        self.stash_ref = stash_ref  # e.g., "stash@{0}"
        self.description = description
        self.branch = branch
        self.timestamp = timestamp
        self.files_count = files_count
        self.datetime = self._parse_timestamp(timestamp)

    def _parse_timestamp(self, timestamp: str) -> datetime:
        """Parse Git timestamp to datetime"""
        try:
            # Git stash timestamp format: "Mon Jan 15 14:30:25 2024 -0800"
            # Strip timezone for simpler parsing
            timestamp_clean = re.sub(r'\s+[+-]\d{4}$', '', timestamp)
            return datetime.strptime(timestamp_clean, "%a %b %d %H:%M:%S %Y")
        except ValueError:
            return datetime.now()

    def age_str(self) -> str:
        """Get human-readable age of stash"""
        now = datetime.now()
        diff = now - self.datetime

        if diff.days > 30:
            return f"{diff.days // 30} months ago"
        elif diff.days > 0:
            return f"{diff.days} days ago"
        elif diff.seconds > 3600:
            return f"{diff.seconds // 3600} hours ago"
        else:
            return f"{diff.seconds // 60} minutes ago"

    def summary(self) -> str:
        """Get summary line for stash"""
        files_info = f" ({self.files_count} files)" if self.files_count > 0 else ""
        return f"{self.stash_ref}: {self.description} [{self.branch}] {self.age_str()}{files_info}"


class GitStashSmart:
    def __init__(self):
        self.config_dir = Path.home() / '.git-stash-smart'
        self.config_dir.mkdir(exist_ok=True)
        self.aliases_file = self.config_dir / 'aliases.json'
        self.load_aliases()

    def load_aliases(self):
        """Load stash aliases/descriptions"""
        if self.aliases_file.exists():
            with open(self.aliases_file, 'r') as f:
                self.aliases = json.load(f)
        else:
            self.aliases = {}

    def save_aliases(self):
        """Save stash aliases/descriptions"""
        with open(self.aliases_file, 'w') as f:
            json.dump(self.aliases, f, indent=2)

    def run_git(self, cmd: List[str], check: bool = True, capture_output: bool = True) -> str:
        """Run git command safely"""
        try:
            result = subprocess.run(
                ['git'] + cmd,
                check=check,
                capture_output=capture_output,
                text=True
            )
            return result.stdout.strip() if capture_output else ""
        except subprocess.CalledProcessError as e:
            if capture_output and e.stderr:
                raise GitStashSmartError(f"Git command failed: {' '.join(cmd)}\n{e.stderr}")
            else:
                raise GitStashSmartError(f"Git command failed: {' '.join(cmd)}")

    def get_stashes(self) -> List[StashInfo]:
        """Get all stashes with enhanced information"""
        try:
            # Get stash list with format: ref:subject:date
            stash_output = self.run_git(['stash', 'list', '--pretty=format:%gd:%s:%cd'])
            if not stash_output:
                return []

            stashes = []
            for line in stash_output.split('\n'):
                if not line.strip():
                    continue

                parts = line.split(':', 2)
                if len(parts) != 3:
                    continue

                stash_ref, subject, timestamp = parts

                # Extract branch from subject (format: "WIP on branch: description")
                branch_match = re.match(r'WIP on ([^:]+):', subject)
                branch = branch_match.group(1) if branch_match else "unknown"

                # Clean description
                description = re.sub(r'^WIP on [^:]+:\s*', '', subject)
                if not description:
                    description = "No description"

                # Get file count for this stash
                try:
                    stat_output = self.run_git(['stash', 'show', '--stat', stash_ref])
                    files_count = len([l for l in stat_output.split('\n') if '|' in l])
                except GitStashSmartError:
                    files_count = 0

                # Check for custom alias
                if stash_ref in self.aliases:
                    description = self.aliases[stash_ref]

                stashes.append(StashInfo(stash_ref, description, branch, timestamp, files_count))

            return stashes

        except GitStashSmartError:
            return []

    def find_stash(self, identifier: str) -> Optional[StashInfo]:
        """Find stash by ID, keyword, or description"""
        stashes = self.get_stashes()

        # Try exact stash reference first
        if identifier.startswith('stash@{') and identifier.endswith('}'):
            for stash in stashes:
                if stash.stash_ref == identifier:
                    return stash

        # Try numeric index
        try:
            index = int(identifier)
            if 0 <= index < len(stashes):
                return stashes[index]
        except ValueError:
            pass

        # Search by keyword in description
        keyword_matches = []
        for stash in stashes:
            if identifier.lower() in stash.description.lower():
                keyword_matches.append(stash)

        if len(keyword_matches) == 1:
            return keyword_matches[0]
        elif len(keyword_matches) > 1:
            print(f"Multiple stashes match '{identifier}':")
            for i, stash in enumerate(keyword_matches):
                print(f"  {i}: {stash.summary()}")
            choice = input("Select stash number: ").strip()
            try:
                idx = int(choice)
                if 0 <= idx < len(keyword_matches):
                    return keyword_matches[idx]
            except ValueError:
                pass

        return None

    def save_stash(self, description: str, include_untracked: bool = False):
        """Save stash with descriptive name"""
        if not description.strip():
            raise GitStashSmartError("Description is required")

        # Check if there are changes to stash
        try:
            self.run_git(['diff-index', '--quiet', 'HEAD'])
            # Also check for untracked files if requested
            if include_untracked:
                untracked = self.run_git(['ls-files', '--others', '--exclude-standard'])
                if not untracked:
                    print("No changes to stash")
                    return
            else:
                print("No changes to stash")
                return
        except GitStashSmartError:
            pass  # Good, there are changes

        # Create stash with custom message
        branch = self.run_git(['branch', '--show-current'])
        stash_message = f"WIP on {branch}: {description.strip()}"

        cmd = ['stash', 'push', '-m', stash_message]
        if include_untracked:
            cmd.append('--include-untracked')

        self.run_git(cmd)

        # Get the new stash reference and save alias
        stashes = self.get_stashes()
        if stashes:
            new_stash = stashes[0]  # Most recent stash
            self.aliases[new_stash.stash_ref] = description.strip()
            self.save_aliases()

        print(f"üíæ Saved stash: {description}")

    def list_stashes(self, verbose: bool = False):
        """List all stashes with enhanced formatting"""
        stashes = self.get_stashes()

        if not stashes:
            print("No stashes found")
            return

        print(f"üìö Found {len(stashes)} stashes:\n")

        for i, stash in enumerate(stashes):
            print(f"  {i}: {stash.summary()}")

            if verbose:
                try:
                    # Show file summary
                    stat_output = self.run_git(['stash', 'show', '--stat', stash.stash_ref])
                    if stat_output:
                        lines = stat_output.split('\n')
                        for line in lines[:3]:  # Show first few files
                            if '|' in line:
                                print(f"      {line.strip()}")
                        if len(lines) > 4:
                            print(f"      ... and {len(lines) - 4} more files")
                except GitStashSmartError:
                    pass
                print()

    def show_stash(self, identifier: str):
        """Show contents of a stash"""
        stash = self.find_stash(identifier)
        if not stash:
            raise GitStashSmartError(f"Stash not found: {identifier}")

        print(f"üìÑ Stash: {stash.summary()}\n")

        # Show stash contents
        try:
            self.run_git(['stash', 'show', '-p', stash.stash_ref], capture_output=False)
        except GitStashSmartError:
            print("Could not show stash contents")

    def apply_stash(self, identifier: str):
        """Apply stash (keep in stash list)"""
        stash = self.find_stash(identifier)
        if not stash:
            raise GitStashSmartError(f"Stash not found: {identifier}")

        print(f"üîÑ Applying stash: {stash.description}")

        try:
            self.run_git(['stash', 'apply', stash.stash_ref])
            print(f"‚úÖ Applied stash successfully")
        except GitStashSmartError as e:
            print(f"‚ùå Failed to apply stash: {e}")

    def pop_stash(self, identifier: str):
        """Pop stash (remove from stash list)"""
        stash = self.find_stash(identifier)
        if not stash:
            raise GitStashSmartError(f"Stash not found: {identifier}")

        print(f"üîÑ Popping stash: {stash.description}")

        try:
            self.run_git(['stash', 'pop', stash.stash_ref])

            # Remove alias
            if stash.stash_ref in self.aliases:
                del self.aliases[stash.stash_ref]
                self.save_aliases()

            print(f"‚úÖ Popped stash successfully")
        except GitStashSmartError as e:
            print(f"‚ùå Failed to pop stash: {e}")

    def drop_stash(self, identifier: str):
        """Delete a stash"""
        stash = self.find_stash(identifier)
        if not stash:
            raise GitStashSmartError(f"Stash not found: {identifier}")

        print(f"‚ö†Ô∏è  Delete stash: {stash.description}")
        confirm = input("Are you sure? (yes/no): ").lower().strip()

        if confirm not in ['yes', 'y']:
            print("Cancelled")
            return

        try:
            self.run_git(['stash', 'drop', stash.stash_ref])

            # Remove alias
            if stash.stash_ref in self.aliases:
                del self.aliases[stash.stash_ref]
                self.save_aliases()

            print(f"üóëÔ∏è  Dropped stash successfully")
        except GitStashSmartError as e:
            print(f"‚ùå Failed to drop stash: {e}")

    def search_stashes(self, keyword: str):
        """Search stashes by keyword"""
        stashes = self.get_stashes()
        matches = []

        for stash in stashes:
            if keyword.lower() in stash.description.lower():
                matches.append(stash)

        if not matches:
            print(f"No stashes found matching '{keyword}'")
            return

        print(f"üîç Found {len(matches)} stashes matching '{keyword}':\n")
        for i, stash in enumerate(matches):
            print(f"  {i}: {stash.summary()}")

    def diff_stash(self, identifier: str):
        """Show diff for stash"""
        stash = self.find_stash(identifier)
        if not stash:
            raise GitStashSmartError(f"Stash not found: {identifier}")

        print(f"üìä Diff for stash: {stash.description}\n")

        try:
            self.run_git(['stash', 'show', '-p', stash.stash_ref], capture_output=False)
        except GitStashSmartError:
            print("Could not show stash diff")

    def create_branch_from_stash(self, branch_name: str, identifier: str):
        """Create branch from stash"""
        stash = self.find_stash(identifier)
        if not stash:
            raise GitStashSmartError(f"Stash not found: {identifier}")

        print(f"üåø Creating branch '{branch_name}' from stash: {stash.description}")

        try:
            # Create and checkout new branch from stash
            self.run_git(['stash', 'branch', branch_name, stash.stash_ref])

            # Remove alias since stash is consumed
            if stash.stash_ref in self.aliases:
                del self.aliases[stash.stash_ref]
                self.save_aliases()

            print(f"‚úÖ Created branch '{branch_name}' successfully")
        except GitStashSmartError as e:
            print(f"‚ùå Failed to create branch: {e}")

    def clean_stashes(self):
        """Interactive cleanup of old stashes"""
        stashes = self.get_stashes()

        if not stashes:
            print("No stashes to clean")
            return

        print("üßπ Stash cleanup - select stashes to delete:\n")

        old_stashes = []
        for stash in stashes:
            age_days = (datetime.now() - stash.datetime).days
            if age_days > 30:  # Older than 30 days
                old_stashes.append(stash)

        if not old_stashes:
            print("No old stashes found (older than 30 days)")
            return

        print(f"Found {len(old_stashes)} stashes older than 30 days:")
        for i, stash in enumerate(old_stashes):
            print(f"  {i}: {stash.summary()}")

        print("\nSelect stashes to delete (comma-separated numbers, or 'all'):")
        selection = input("> ").strip().lower()

        if selection == 'all':
            to_delete = old_stashes
        else:
            try:
                indices = [int(x.strip()) for x in selection.split(',')]
                to_delete = [old_stashes[i] for i in indices if 0 <= i < len(old_stashes)]
            except (ValueError, IndexError):
                print("Invalid selection")
                return

        if not to_delete:
            print("No stashes selected")
            return

        print(f"\nWill delete {len(to_delete)} stashes:")
        for stash in to_delete:
            print(f"  - {stash.description}")

        confirm = input("\nProceed? (yes/no): ").lower().strip()
        if confirm not in ['yes', 'y']:
            print("Cancelled")
            return

        # Delete selected stashes
        deleted_count = 0
        for stash in to_delete:
            try:
                self.run_git(['stash', 'drop', stash.stash_ref])
                if stash.stash_ref in self.aliases:
                    del self.aliases[stash.stash_ref]
                deleted_count += 1
            except GitStashSmartError:
                print(f"Failed to delete: {stash.description}")

        if deleted_count > 0:
            self.save_aliases()
            print(f"üóëÔ∏è  Deleted {deleted_count} stashes")


def main():
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    subparsers = parser.add_subparsers(dest='command', help='Commands')

    # Save command
    save_parser = subparsers.add_parser('save', help='Save stash with description')
    save_parser.add_argument('description', help='Stash description')
    save_parser.add_argument('-u', '--include-untracked', action='store_true',
                           help='Include untracked files')

    # List command
    list_parser = subparsers.add_parser('list', help='List all stashes')
    list_parser.add_argument('-v', '--verbose', action='store_true',
                           help='Show detailed information')

    # Show command
    show_parser = subparsers.add_parser('show', help='Show stash contents')
    show_parser.add_argument('identifier', help='Stash ID, number, or keyword')

    # Apply command
    apply_parser = subparsers.add_parser('apply', help='Apply stash (keep in list)')
    apply_parser.add_argument('identifier', help='Stash ID, number, or keyword')

    # Pop command
    pop_parser = subparsers.add_parser('pop', help='Pop stash (remove from list)')
    pop_parser.add_argument('identifier', help='Stash ID, number, or keyword')

    # Drop command
    drop_parser = subparsers.add_parser('drop', help='Delete stash')
    drop_parser.add_argument('identifier', help='Stash ID, number, or keyword')

    # Search command
    search_parser = subparsers.add_parser('search', help='Search stashes by keyword')
    search_parser.add_argument('keyword', help='Search keyword')

    # Diff command
    diff_parser = subparsers.add_parser('diff', help='Show stash diff')
    diff_parser.add_argument('identifier', help='Stash ID, number, or keyword')

    # Branch command
    branch_parser = subparsers.add_parser('branch', help='Create branch from stash')
    branch_parser.add_argument('name', help='Branch name')
    branch_parser.add_argument('identifier', help='Stash ID, number, or keyword')

    # Clean command
    subparsers.add_parser('clean', help='Interactive cleanup of old stashes')

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return

    try:
        stash_manager = GitStashSmart()

        if args.command == 'save':
            stash_manager.save_stash(args.description, args.include_untracked)
        elif args.command == 'list':
            stash_manager.list_stashes(args.verbose)
        elif args.command == 'show':
            stash_manager.show_stash(args.identifier)
        elif args.command == 'apply':
            stash_manager.apply_stash(args.identifier)
        elif args.command == 'pop':
            stash_manager.pop_stash(args.identifier)
        elif args.command == 'drop':
            stash_manager.drop_stash(args.identifier)
        elif args.command == 'search':
            stash_manager.search_stashes(args.keyword)
        elif args.command == 'diff':
            stash_manager.diff_stash(args.identifier)
        elif args.command == 'branch':
            stash_manager.create_branch_from_stash(args.name, args.identifier)
        elif args.command == 'clean':
            stash_manager.clean_stashes()

    except GitStashSmartError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        print("\nCancelled")
        sys.exit(1)


if __name__ == '__main__':
    main()
