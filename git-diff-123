#!/usr/bin/env ruby
# encoding: utf-8

require 'tempfile'
require 'tmpdir'
require 'json'

def get_git_editor
  editor = `git config core.editor`.strip
  editor.empty? ? 'vim' : editor
end

def check_merge_conflict(file)
  `git ls-files -u #{file}`.strip.empty?
end

def extract_conflict_files(file, json_output = false)
  if check_merge_conflict(file)
    if json_output
      puts JSON.generate({error: "'#{file}' is not in a merge conflict state."})
    else
      puts "Error: '#{file}' is not in a merge conflict state."
    end
    exit 1
  end

  tmpdir = Dir.mktmpdir("git-diff-123-")
  file_theirs = File.join(tmpdir, 'theirs')
  file_ours = File.join(tmpdir, 'ours')
  file_base = File.join(tmpdir, 'base')

  system "git show :3:#{file} > #{file_theirs}"
  system "git show :2:#{file} > #{file_ours}"
  system "git show :1:#{file} > #{file_base}"

  if json_output
    puts JSON.generate({
      tmpdir: tmpdir,
      ours: file_ours,
      base: file_base,
      theirs: file_theirs
    })
  else
    puts "#{tmpdir}:#{file_ours}:#{file_base}:#{file_theirs}"
  end
end

def remerge_from_files(file, ours_path, base_path, theirs_path)
  unless File.exist?(ours_path) && File.exist?(base_path) && File.exist?(theirs_path)
    puts "Error: One or more temp files not found"
    exit 1
  end

  puts "Re-merging with edited files..."
  merge_result = `git merge-file #{ours_path} #{base_path} #{theirs_path} 2>&1`

  if $?.success?
    system "cp #{ours_path} #{file}"
    puts "Clean merge successful! Applied to #{file}"
    puts "\nShowing diff and staging file..."
    system "git diff #{file}"
    system "git add #{file}"
    puts "File staged successfully."
  else
    puts "Re-merge failed with conflicts. Original file unchanged."
    puts "Merge output: #{merge_result}" unless merge_result.strip.empty?
    puts "To see the conflicted version, check the temporary file: #{ours_path}"
  end
end

def main
  json_output = ARGV.delete('--json')

  if ARGV[0] == '--extract'
    file = ARGV[1]
    unless file
      puts("USAGE: #{File.basename __FILE__} --extract [--json] FILE")
      exit 0
    end
    extract_conflict_files(file, json_output)
    return
  end

  if ARGV[0] == '--remerge'
    file, ours_path, base_path, theirs_path = ARGV[1], ARGV[2], ARGV[3], ARGV[4]
    unless file && ours_path && base_path && theirs_path
      puts("USAGE: #{File.basename __FILE__} --remerge FILE OURS_PATH BASE_PATH THEIRS_PATH")
      exit 0
    end
    remerge_from_files(file, ours_path, base_path, theirs_path)
    return
  end

  file = ARGV.shift
  unless file
    puts("USAGE: #{File.basename __FILE__} FILE")
    puts("       #{File.basename __FILE__} --extract [--json] FILE")
    puts("       #{File.basename __FILE__} --remerge FILE OURS_PATH BASE_PATH THEIRS_PATH")
    exit 0
  end

  if check_merge_conflict(file)
    puts "Error: '#{file}' is not in a merge conflict state."
    exit 1
  end

  editor = get_git_editor

  Dir.mktmpdir do |tmpdir|
    file_theirs = File.join(tmpdir, 'theirs')
    file_ours = File.join(tmpdir, 'ours')
    file_base = File.join(tmpdir, 'base')

    system "git show :3:#{file} > #{file_theirs}"
    system "git show :2:#{file} > #{file_ours}"
    system "git show :1:#{file} > #{file_base}"

    loop do
      puts "
Choose a diff to view for '#{file}':"
      puts "1. Theirs vs. Merged"
      puts "2. Ours vs. Merged"
      puts "3. Theirs vs. Ours"
      puts "4. Re-merge with edited files"
      puts "q. Quit"
      print "> "
      choice = STDIN.gets.strip

      case choice
      when '1'
        system "#{editor} -c 'set diffopt+=iwhite' -d #{file_theirs} #{file}"
      when '2'
        system "#{editor} -c 'set diffopt+=iwhite' -d #{file_ours} #{file}"
      when '3'
        system "#{editor} -c 'set diffopt+=iwhite' -d #{file_theirs} #{file_ours}"
      when '4'
        puts "Re-merging with edited files..."
        merge_result = `git merge-file #{file_ours} #{file_base} #{file_theirs} 2>&1`

        if $?.success?
          system "cp #{file_ours} #{file}"
          puts "Clean merge successful! Applied to #{file}"
          puts "\nShowing diff and staging file..."
          system "git diff #{file}"
          system "git add #{file}"
          puts "File staged successfully."
        else
          puts "Re-merge failed with conflicts. Original file unchanged."
          puts "Merge output: #{merge_result}" unless merge_result.strip.empty?
          puts "To see the conflicted version, check the temporary file: #{file_ours}"
        end
      when 'q'
        break
      else
        puts "Invalid choice."
      end
    end
  end
end

main
