#!/usr/bin/env bash
set -euo pipefail

# =============================================================================
# git-remove-from-history - Remove File/Directory from Git History
# =============================================================================
#
# PURPOSE:
#   Completely removes a file or directory from all Git history using git-filter-repo.
#   This rewrites history to permanently delete the specified path from all commits,
#   branches, and tags as if it never existed.
#
# ⚠️  WARNING: DESTRUCTIVE OPERATION ⚠️
#   - Rewrites ALL Git history
#   - Changes ALL commit hashes
#   - Breaks existing clones (force-push required)
#   - Cannot be easily undone
#   - Requires team coordination
#
# SAFETY FEATURES:
#   - Creates backup branch automatically
#   - Dry-run mode by default
#   - Dependency verification
#   - Working directory cleanliness check
#   - Remote safety verification
#   - Post-operation verification
#
# USAGE:
#   git-remove-from-history --path <path> [--apply] [--force]
#
# EXAMPLES:
#   git-remove-from-history --path secrets.txt           # Dry-run preview
#   git-remove-from-history --path secrets.txt --apply   # Actually remove
#   git-remove-from-history --path config/ --apply       # Remove directory
#
# REQUIREMENTS:
#   - git-filter-repo (install: pip install git-filter-repo)
#   - Clean working directory (no uncommitted changes)
#   - Local-only branch (not pushed to remote, unless --force)
#
# =============================================================================

# Colors for output
GREEN='\033[0;32m'
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BOLD='\033[1m'
NC='\033[0m' # No color

# Global variables
TARGET_PATH=""
APPLY=false
FORCE=false
BACKUP_BRANCH=""

# Set secure file permissions for temp files
umask 077

# Usage function
usage() {
    cat << 'EOF'
Usage: git-remove-from-history --path <path> [--apply] [--force]

Remove file/directory from all Git history (DESTRUCTIVE).

Required:
  --path <path>        File or directory to remove from history

Options:
  --apply              Actually perform the removal (default: dry-run)
  --force              Force operation even on pushed branches
  -h, --help           Show this help message

Examples:
  git-remove-from-history --path secrets.txt           # Preview only
  git-remove-from-history --path secrets.txt --apply   # Actually remove
  git-remove-from-history --path config/ --apply       # Remove directory

⚠️  WARNING: This rewrites ALL Git history and changes ALL commit hashes!
   - Creates backup branch before starting
   - Requires force-push to remote repositories
   - Breaks existing clones and requires team coordination
   - Cannot be easily undone

Safety Features:
  - Automatic backup branch creation
  - Dry-run mode by default
  - Working directory cleanliness check
  - Remote safety verification (bypassed with --force)
  - Post-operation verification

Requirements:
  - git-filter-repo (install: pip install git-filter-repo)
  - Clean working directory (no uncommitted changes)
  - Preferably local-only branch (not pushed to remote)
EOF
    exit 1
}

# Utility function for consistent error handling
error_exit() {
    local message="$1"
    local exit_code="${2:-1}"
    echo -e "${RED}[ERROR] $message${NC}" >&2
    exit "$exit_code"
}

# Dependency checks
check_dependencies() {
    echo -e "${CYAN}[INFO] Checking dependencies...${NC}"
    
    if ! command -v git-filter-repo >/dev/null 2>&1; then
        error_exit "git-filter-repo not found\nInstall with one of:\n  pip install git-filter-repo\n  brew install git-filter-repo\n  apt install git-filter-repo"
    fi
    
    echo -e "${GREEN}[✓] git-filter-repo found${NC}"
}

# Git repository checks
check_git_repo() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        error_exit "Not in a Git repository"
    fi
}

# Working directory cleanliness check
check_working_directory_clean() {
    echo -e "${CYAN}[INFO] Checking working directory...${NC}"
    
    # Check for concurrent git operations
    if [[ -f ".git/index.lock" ]]; then
        echo -e "${RED}[ERROR] Git operation in progress (index.lock exists)${NC}"
        echo "Wait for completion or remove stale lock file"
        error_exit "Concurrent git operation detected"
    fi
    
    # Check for staged changes
    if git status --porcelain | grep -q '^[MADRC]'; then
        echo -e "${RED}[ERROR] Staged changes detected${NC}"
        echo "Please commit or reset staged changes before proceeding:"
        git status --porcelain | grep '^[MADRC]'
        error_exit "Repository has staged changes"
    fi
    
    # Check for unstaged changes
    if ! git diff-index --quiet HEAD --; then
        echo -e "${RED}[ERROR] Working directory has uncommitted changes${NC}"
        echo "Please commit or stash changes before proceeding:"
        git status --porcelain
        error_exit "Repository has uncommitted changes"
    fi
    
    # Check for untracked files
    if git status --porcelain | grep -q '^??'; then
        echo -e "${YELLOW}[WARN] Untracked files detected${NC}"
        echo "For complete safety, please handle untracked files first:"
        git status --porcelain | grep '^??' | sed 's/^/  /'
        echo
        read -r -p "Continue anyway? [y/N]:" response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            error_exit "Operation cancelled - please handle untracked files first"
        fi
    fi
    
    echo -e "${GREEN}[✓] Working directory is clean${NC}"
}

# Remote safety verification
check_remote_safety() {
    if [[ "$FORCE" == true ]]; then
        echo -e "${YELLOW}[WARN] Skipping remote safety check (--force used)${NC}"
        return 0
    fi
    
    echo -e "${CYAN}[INFO] Checking remote safety...${NC}"
    
    local current_branch
    current_branch=$(git branch --show-current)
    
    # Check if branch has a remote tracking branch
    if git config --get "branch.${current_branch}.remote" >/dev/null 2>&1; then
        local remote_branch
        remote_branch=$(git config --get "branch.${current_branch}.merge" | sed 's|refs/heads/||')
        local remote_name
        remote_name=$(git config --get "branch.${current_branch}.remote")
        local remote_ref="${remote_name}/${remote_branch}"
        
        echo -e "${YELLOW}[WARN] Current branch '${current_branch}' tracks '${remote_ref}'${NC}"
        
        # First check if remote ref exists locally
        if ! git rev-parse --verify "$remote_ref" >/dev/null 2>&1; then
            echo -e "${RED}[ERROR] Remote reference '${remote_ref}' not found locally${NC}"
            echo "This suggests the branch may have been pushed but remote tracking is stale."
            echo "Run 'git fetch' first, or use --force if you're certain this is safe."
            error_exit "Cannot verify remote status - run 'git fetch' first or use --force"
        fi
        
        # Check the relationship between local and remote
        local local_commit remote_commit
        local_commit=$(git rev-parse HEAD)
        remote_commit=$(git rev-parse "$remote_ref")
        
        if [[ "$local_commit" == "$remote_commit" ]]; then
            echo -e "${RED}[ERROR] Branch is identical to remote (fully pushed)${NC}"
            echo "Rewriting history on pushed branches is extremely dangerous!"
            echo "This will break existing clones and require team coordination."
            echo "Use --force only if you're absolutely certain and have coordinated with your team."
            error_exit "Operation blocked for safety - branch is fully pushed to remote"
        fi
        
        # Check if local is ahead of remote
        if git merge-base --is-ancestor "$remote_ref" HEAD; then
            local unpushed_count
            unpushed_count=$(git rev-list --count "${remote_ref}..HEAD")
            echo -e "${GREEN}[✓] Branch has ${unpushed_count} unpushed commits${NC}"
        else
            # Local is behind or diverged from remote
            echo -e "${RED}[ERROR] Local branch has diverged from or is behind remote${NC}"
            echo "This is a complex situation that requires manual resolution."
            echo "Consider: git fetch && git status to understand the situation."
            error_exit "Branch has diverged from remote - resolve manually first"
        fi
    else
        echo -e "${GREEN}[✓] Branch has no remote tracking${NC}"
    fi
}

# Path validation and sanitization
validate_and_sanitize_path() {
    local path="$1"
    
    # Check for empty path
    if [[ -z "$path" ]]; then
        echo -e "${RED}[ERROR] Path cannot be empty${NC}"
        exit 1
    fi
    
    # Check for whitespace-only path
    if [[ "$path" =~ ^[[:space:]]*$ ]]; then
        echo -e "${RED}[ERROR] Path cannot be whitespace-only${NC}"
        exit 1
    fi
    
    # Basic sanitization - remove dangerous characters
    if echo "$path" | grep -qE '[;&|`$()]'; then
        echo -e "${RED}[ERROR] Path contains potentially dangerous characters: $path${NC}"
        exit 1
    fi
    
    # Normalize path (remove double slashes, trailing slashes)
    path=$(echo "$path" | sed 's|//*|/|g' | sed 's|/$||')
    
    # Final validation - ensure path is not just slashes or dots
    if [[ "$path" =~ ^[./]*$ ]]; then
        echo -e "${RED}[ERROR] Invalid path pattern: $path${NC}"
        exit 1
    fi
    
    echo "$path"
}

# Check if path exists in Git history
check_path_in_history() {
    local path="$1"
    
    echo -e "${CYAN}[INFO] Analyzing path '$path' in Git history...${NC}"
    
    if git log --all --full-history --oneline -- "$path" >/dev/null 2>&1; then
        local commit_count
        commit_count=$(git log --all --oneline --full-history -- "$path" | wc -l | tr -d ' ')
        
        if [[ "$commit_count" -gt 0 ]]; then
            echo -e "${CYAN}[INFO] Found $commit_count commits containing '$path'${NC}"
            return 0
        fi
    fi
    
    echo -e "${YELLOW}[WARN] Path '$path' not found in Git history${NC}"
    echo "This operation will have no effect."
    
    if [[ "$APPLY" == true ]]; then
        error_exit "Cannot remove non-existent path"
    fi
    
    return 1
}

# Create backup branch
create_backup() {
    local timestamp
    timestamp=$(date +%Y%m%d_%H%M%S)
    local current_branch
    current_branch=$(git branch --show-current)
    
    BACKUP_BRANCH="backup_${current_branch}_${timestamp}"
    
    echo -e "${CYAN}[INFO] Creating backup branch: $BACKUP_BRANCH${NC}"
    
    if ! git branch "$BACKUP_BRANCH"; then
        error_exit "Failed to create backup branch: $BACKUP_BRANCH"
    fi
    
    echo -e "${GREEN}[✓] Backup branch created: $BACKUP_BRANCH${NC}"
}

# Enhanced dry-run mode
perform_dry_run() {
    local path="$1"
    
    echo
    echo -e "${BOLD}=== DRY-RUN MODE ===${NC}"
    echo -e "${YELLOW}This is a preview. No changes will be made.${NC}"
    echo
    
    echo -e "${CYAN}Target path:${NC} $path"
    echo
    
    if check_path_in_history "$path"; then
        echo -e "${CYAN}Files/directories that would be removed:${NC}"
        git log --all --full-history --name-only --pretty=format: -- "$path" 2>/dev/null | sort -u | grep -v '^$' | head -20 | sed 's/^/  /'
        
        local total_files
        total_files=$(git log --all --full-history --name-only --pretty=format: -- "$path" 2>/dev/null | sort -u | grep -v '^$' | wc -l | tr -d ' ')
        if [[ "$total_files" -gt 20 ]]; then
            echo "  ... and $((total_files - 20)) more files"
        fi
        echo
        
        echo -e "${CYAN}Recent commits that would be modified:${NC}"
        git log --oneline --max-count=10 --all --full-history -- "$path" 2>/dev/null | sed 's/^/  /' || true
        echo
        
        # Show current repository size
        echo -e "${CYAN}Current repository size:${NC} $(du -sh .git 2>/dev/null | cut -f1 || echo "Unknown")"
        
        if [[ -e "$path" ]]; then
            echo -e "${CYAN}Current path size on disk:${NC} $(du -sh "$path" 2>/dev/null | cut -f1 || echo "Unknown")"
        fi
    fi
    
    echo
    echo -e "${YELLOW}What would happen:${NC}"
    echo "1. Create backup branch: backup_\$(current_branch)_\$(timestamp)"
    echo "2. Use git-filter-repo to remove '$path' from ALL commits"
    echo "3. Update all branch and tag references"
    echo "4. Clean up refs and reflog"
    echo "5. Verify removal was successful"
    echo
    echo -e "${RED}⚠️  This would:${NC}"
    echo "   - Rewrite ALL Git history"
    echo "   - Change ALL commit hashes"
    echo "   - Require force-push to remote repositories"
    echo "   - Break existing clones (team coordination required)"
    echo
    echo -e "${YELLOW}To perform the actual removal:${NC}"
    echo "    git-remove-from-history --path '$path' --apply"
    echo
    echo -e "${CYAN}Recovery (if needed):${NC}"
    echo "    git checkout backup_\$(current_branch)_\$(timestamp)"
    echo "    git branch -D \$(current_branch)"
    echo "    git checkout -b \$(current_branch)"
}

# Perform the actual removal
perform_removal() {
    local path="$1"
    
    echo
    echo -e "${CYAN}[INFO] Removing '$path' from Git history...${NC}"
    echo -e "${YELLOW}[WARN] This may take a while for large repositories...${NC}"
    
    # Store remote configurations before git-filter-repo removes them
    local remotes_backup=$(mktemp)
    git remote -v > "$remotes_backup" 2>/dev/null || true
    
    # Use git-filter-repo to remove the path
    if ! git filter-repo --path "$path" --invert-paths --force; then
        echo -e "${RED}[ERROR] git-filter-repo failed${NC}"
        echo -e "${CYAN}[INFO] You can recover using backup branch: $BACKUP_BRANCH${NC}"
        echo "Recovery command: git reset --hard $BACKUP_BRANCH"
        rm -f "$remotes_backup"
        error_exit "History rewriting operation failed"
    fi
    
    # Restore remote configurations (git-filter-repo removes them as safety)
    echo -e "${CYAN}[INFO] Restoring remote configurations...${NC}"
    if [[ -s "$remotes_backup" ]]; then
        while IFS=$'\t' read -r remote_line || [[ -n "$remote_line" ]]; do
            if [[ -n "$remote_line" ]]; then
                local remote_name=$(echo "$remote_line" | awk '{print $1}')
                local remote_url=$(echo "$remote_line" | awk '{print $2}')
                local remote_type=$(echo "$remote_line" | awk '{print $3}' | tr -d '()')
                
                # Only add fetch URLs (avoid duplicating push URLs)
                if [[ "$remote_type" == "fetch" ]] || [[ -z "$remote_type" ]]; then
                    if ! git remote add "$remote_name" "$remote_url" 2>/dev/null; then
                        git remote set-url "$remote_name" "$remote_url" 2>/dev/null || true
                    fi
                fi
            fi
        done < "$remotes_backup"
        echo -e "${GREEN}[✓] Remote configurations restored${NC}"
    else
        echo -e "${YELLOW}[WARN] No remote configurations to restore${NC}"
    fi
    
    rm -f "$remotes_backup"
    echo -e "${GREEN}[✓] Path removed from history${NC}"
}

# Verify removal was successful
verify_removal() {
    local path="$1"
    
    echo -e "${CYAN}[INFO] Verifying removal...${NC}"
    
    # Check if path still exists in history
    if git log --all --full-history --oneline -- "$path" 2>/dev/null | head -1 | grep -q .; then
        echo -e "${RED}[ERROR] Path '$path' still appears in git history${NC}"
        echo "The removal may not have been completely successful"
        echo -e "${CYAN}[INFO] You can recover using backup branch: $BACKUP_BRANCH${NC}"
        exit 1
    fi
    
    echo -e "${GREEN}[✓] Path successfully removed from git history${NC}"
    
    # Clean up refs and reflog
    echo -e "${CYAN}[INFO] Cleaning up refs and reflog...${NC}"
    git reflog expire --expire=now --all >/dev/null 2>&1 || true
    git gc --prune=now --aggressive >/dev/null 2>&1 || true
    
    # Show final size
    echo -e "${CYAN}[INFO] Final repository size:${NC} $(du -sh .git 2>/dev/null | cut -f1 || echo "Unknown")"
}

# Parse command line arguments
parse_arguments() {
    if [[ $# -eq 0 ]]; then
        usage
    fi
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --path)
                shift
                TARGET_PATH="$1"
                ;;
            --apply)
                APPLY=true
                ;;
            --force)
                FORCE=true
                ;;
            -h|--help)
                usage
                ;;
            *)
                error_exit "Unknown option: $1\nUse --help for usage information"
                ;;
        esac
        shift
    done
    
    if [[ -z "$TARGET_PATH" ]]; then
        error_exit "--path is required\nUse --help for usage information"
    fi
}

# Final confirmation for destructive operation
get_final_confirmation() {
    local path="$1"
    
    echo
    echo -e "${RED}${BOLD}⚠️  FINAL WARNING ⚠️${NC}"
    echo -e "${RED}This will PERMANENTLY remove '$path' from ALL Git history!${NC}"
    echo -e "${RED}This operation CANNOT be easily undone!${NC}"
    echo
    echo -e "${CYAN}Backup will be created:${NC} $BACKUP_BRANCH"
    echo
    read -r -p "Type 'REMOVE' to confirm: " confirm
    if [[ "$confirm" != "REMOVE" ]]; then
        echo -e "${YELLOW}[CANCELLED] Operation cancelled by user${NC}"
        exit 0
    fi
}

# Main execution function
main() {
    echo -e "${BOLD}=== Git History Removal Tool ===${NC}"
    echo
    
    parse_arguments "$@"
    check_dependencies
    check_git_repo
    check_working_directory_clean
    
    TARGET_PATH=$(validate_and_sanitize_path "$TARGET_PATH")
    
    echo -e "${CYAN}Repository:${NC} $(git rev-parse --show-toplevel)"
    echo -e "${CYAN}Current branch:${NC} $(git branch --show-current)"
    echo -e "${CYAN}Target path:${NC} $TARGET_PATH"
    echo
    
    # Dry-run mode
    if [[ "$APPLY" == false ]]; then
        perform_dry_run "$TARGET_PATH"
        exit 0
    fi
    
    # Apply mode - additional safety checks
    check_remote_safety
    check_path_in_history "$TARGET_PATH" || exit 1
    
    create_backup
    get_final_confirmation "$TARGET_PATH"
    
    perform_removal "$TARGET_PATH"
    verify_removal "$TARGET_PATH"
    
    echo
    echo -e "${GREEN}${BOLD}[SUCCESS] Operation completed successfully!${NC}"
    echo
    echo -e "${YELLOW}Next steps:${NC}"
    echo "1. Verify the removal: git log --all --full-history -- '$TARGET_PATH'"
    echo "2. Check remotes are restored: git remote -v"
    echo "3. If satisfied, force-push: git push --force-with-lease --all"
    echo "4. Force-push tags: git push --force-with-lease --tags"
    echo "5. Notify team members to re-clone repository"
    echo
    echo -e "${CYAN}Backup branch:${NC} $BACKUP_BRANCH"
    echo -e "${CYAN}Recovery command:${NC} git reset --hard $BACKUP_BRANCH"
}

# Run main function with all arguments
main "$@"
